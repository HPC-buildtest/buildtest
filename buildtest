#!/bin/sh

function usage () {
   cat <<EOF
Usage: buildtest 
   -s --software 	  application name. This must match the module name

   -v --version		  application version. This must match the module version

   -m --modules		  adding extra modules prior to loading application. Use 
			  this to resolve dependencies, if it is not captured in 
			  module file

   -l --list		  List current modules in the system based on variable BUILDTEST_MODROOT. 
			  Check setup.sh to see the path for BUILDTEST_MODROOT

   -b --buildtoolchain	  The toolchain used to build the package. This refers to the EasyBuild toolchain
			  used for building the package. Check your easyconfig to see what toolchain you used. 
	
			  If a package is built with dummy toolchain don't specify this paramter. 
		          Test directory format: <software>/<version>/<toolchain>/<test>.sh
			
			  Toolchain module must be present in order for test to be created.

   -h --help   		  displays basic help

Example:
    1. 	Run test for software GCC version 5.4.0-2.27
       	
    	./buildtest -s GCC -v 5.4.0-2.27

    2. Run test for Python version 2.7.12 built with foss .2016.03  toolchain.
    	./buildtest -s Python -v 2.7.12 -b foss/.2016.03

    3.	Modules should be passed in quotation if adding multiple modules to path
    
    	./buildtest -s netCDF -v 4.4.1 -b intel/2017.01  -m "<module>/<version> <module>/version ..."

EOF
}


source ./setup.sh

software=""
version=""
depmodules=""
parameter=""
template=""
toolchain="dummy/dummy"
testname=""
compiler=""
listpkg="False"
#OPTS=`getopt -o svemptfh: --long verbose,dry-run,help,stack-size: -n 'parse-options' -- "$@"`

#echo $OPTS
#exit 1
# convert long argument names to short 
#let i=0
ARGLIST=$@
for arg in "$@"; do
  shift
  case "$arg" in
    "--software") set -- "$@" "-s" ;;
    "--version") set -- "$@" "-v" ;;
    "--list") set -- "$@" "-l" ;;
    "--modules") set -- "$@" "-m" ;;
    "--buildtoolchain") set -- "$@" "-b" ;;
    "--template") set -- "$@" "-t" ;;
    "--help") set -- "$@" "-h" ;;
    *)        set -- "$@" "$arg"
  esac
done

#sourcepkg=${ARGLIST[$((arg_index+1))]} ;; 
#OPT=`getopt -o s:v:e:m:p:t:f:h --long software:,version:,executable:,modules:,parameter:,template:,file:,help: -- "$@"`
#eval set -- "$OPT"

while getopts ":b:lhm:s:t:v:" opt; do
#while true;
  case $opt in
    b)
        toolchain=$OPTARG
        ;;
    h)
        usage
        exit 0
        ;;
    l)
	listpkg="True"
	;;
    m)
        depmodules=$OPTARG
        ;;
    s)
      	software=$OPTARG
	;;
    t)
        template=$OPTARG
        ;;
    v)
      	version=$OPTARG
      	;;
    \?)
      	echo "Invalid option: -$OPTARG" >&2
      	echo "Please run ./testgen.sh -h for a list of options"
      	exit 1
      	;;
    :)
      	echo "Option -$OPTARG requires an argument." >&2
      	exit 1
      	;;
  esac
done

compilerlist=""
mpilist=""
declare -a namelist=()
declare -a versionlist=()
declare -a compilerlist=()
declare -a compilerver=()
declare -a mpilist=()
declare -a mpiverlist=()

ret=`find $BUILDTEST_MODROOT -type f`
IFS=' ' read -ra modlist <<< $ret
let nameindex=0

for module in ${modlist[@]}; do
	
	#MODULETREE_CORE=`dirname $module | xargs dirname | xargs basename`
	# Modules under Compiler directory in HMNS -> pattern: Compiler/<compiler>/<compiler-ver>/<software>/<version>.lua
	MODULETREE_COMPILER=$(dirname $module | xargs dirname | xargs dirname | xargs dirname | xargs basename)

	# Modules under MPI directory in HMNS -> pattern: MPI/<compiler>/<compiler-ver>/<MPI-wrapper>/<MPI-version>/<software>/<version>.lua
	MODULETREE_MPI=$(dirname $module | xargs dirname | xargs dirname | xargs dirname | xargs dirname | xargs dirname | xargs basename)


	 namelist[$nameindex]=`dirname $module | xargs basename`
	 version_with_extension=`basename $module`
	 # strip text .lua from version
	 versionlist[$nameindex]=${version_with_extension::-4}

	 # Modules under Core directory in HMNS -> pattern: Core/<software>/<version>.lua
	 #if [ "$MODULETREE_CORE"  == "Core" ]; then
	#	compilerlist[$nameindex]="dummy"
	 #	compilerverlist[$nameindex]="dummy"
	 #fi 
	 
	 if [ "$MODULETREE_COMPILER"  == "Compiler" ]; then
		compilerpath=`dirname $module | xargs dirname `
		compilerlist[$nameindex]=`dirname $compilerpath |  xargs basename`
		compilerverlist[$nameindex]=`basename $compilerpath `
	fi
	
	# Modules under MPI directory in HMNS -> pattern: MPI/<compiler>/<compiler-ver>/<MPI-wrapper>/<MPI-version>/<software>/<version>.lua
	 if [ "$MODULETREE_MPI"  == "MPI" ]; then
	 #echo $namelist[$nameindex]
		mpipath=`dirname $module | xargs dirname`
		compilerpath=`dirname $mpipath | xargs dirname`
		mpilist[$nameindex]=`dirname $mpipath | xargs basename`
		mpiverlist[$nameindex]=`basename $mpipath`
		compilerlist[$nameindex]=`dirname $compilerpath | xargs basename`
		compilerverlist[$nameindex]=`basename $compilerpath`
	 fi
	 let "nameindex++"
done

# Show available packages and exit program. --list
if [ $listpkg == "True" ]; then
	for ((i=0; i<${#namelist[@]};i++ ));
	do
		if [ "${compilerlist[$i]}" == ""  ]; then
			echo "Software: ${namelist[$i]}/${versionlist[$i]} "
		elif [ "${mpilist[$i]}" == "" ]; then
			printf "%s\n%s\n" "Software: ${namelist[$i]}/${versionlist[$i]}" "Compiler: ${compilerlist[$i]}/${compilerverlist[$i]}"
		else
			printf "%s\n%s\n%s\n" "Software: ${namelist[$i]}/${versionlist[$i]}" "Compiler:${compilerlist[$i]}/${compilerverlist[$i]}" "MPI: ${mpilist[$i]}/${mpiverlist[$i]} "
		fi
		echo "--------------------------------------------------"
	done
	exit 0
fi

# this statement is only true if user forgets to pass -s and -v. This is required 
if [ "$software" == "" ] || [ "$version" == "" ] ; then
        echo "need to specify option -s & -v in your command"
        exit 1
fi

foundsoftware="false"
foundtoolchain="false"

export BUILDTEST_SRCSWDIR=$BUILDTEST_SRCDIR/$software
cmdfile=$BUILDTEST_SRCSWDIR/command.txt
generic=$BUILDTEST_SRCSWDIR/generic
mpidir=$BUILDTEST_SRCSWDIR/MPI

# extract toolchain name and version from toolchain variable. Split by / to get name and version. Format: <name>/<version>
toolchain_name=`echo $toolchain | cut -f 1 -d /`
toolchain_version=`echo $toolchain | cut -f 2 -d /`

# location where test will reside
destdir=testing/$software/$version/$toolchain_name/$toolchain_version

# verify module is present in system before adding test
for (( i=0; i < ${#namelist[@]}; i++ ));
do
	if [ "$software" == "${namelist[$i]}" ] && [ "$version" == "${versionlist[$i]}" ]; then
		foundsoftware="true"
	fi
	# only check if module exists when toolchain is specified
	if [ "$toolchain_name" == "${namelist[$i]}" ] && [ "$toolchain_version" == "${versionlist[$i]}" ]; then
                foundtoolchain="true"
        fi

	
	
done
if [ $foundsoftware == "false" ]; then
	echo "Can't find module for: $software $version"
	exit 1
fi

# if toolchain opt -b is specified and toolchain module doesn't exist
if [ $toolchain != "dummy/dummy" ] && [ $foundtoolchain == "false" ]; then
	echo "Can't find Toolchain module: $toolchain for: $software $version"
        exit 1
fi

# if toolchain is not specified but software-version module exist in one of the module tree then search the easyconfig files for correct toolchain
#elif [ $toolchain == "dummy/dummy" ]; then

# when version of module file is hidden
if [ ${version:0:1} == "." ]; then
	strip_version=$(echo $version | cut -c2-${#version})
	easyconfig_file=$(find $BUILDTEST_EASYCONFIGDIR -name "$software-$strip_version*.eb")
else
	easyconfig_file=$(find $BUILDTEST_EASYCONFIGDIR -name "$software-$version*.eb")
fi
eb_tc_name=()
eb_tc_ver=()
let index=0
for file in ${easyconfig_file[@]}
do
	eb_tc_name[$index]=$(cat $file | grep "toolchain = *" | cut -f4 -d " " | tr -d ",'")
	eb_tc_ver[$index]=$(cat $file | grep "toolchain = *" | cut -f6 -d " " | tr -d ",'}")
	index=$index+1
	
done

hidden_version_file=false
# if toolchain version is hidden file from command line strip the leading "." when doing comparison
if [ ${toolchain_version:0:1} == "." ]; then
	len=${#toolchain_version}
	# skip 1st character and get all characters from 2nd to end of string
	strip_toolchain_version_hiddenfile=$(echo $toolchain_version | cut -c2-$len)
	hidden_version_file=true
		#echo $toolchain_version:
fi

# boolean variable to determine if the toolchain name and version match the values in easyconfig. If condition is not met, then we halt program
eb_tc_name_match=0
eb_tc_ver_match=0
# only check 
# loop over all easyconfig toolchain name/version values because there could be multiple software version built with different toolchains
for ((i = 0; i < ${#eb_tc_name[@]}; i++))
do
	#echo "BEGIN: name,ver="${eb_tc_name[$i]} ${eb_tc_ver[$i]} "toolchain=" $toolchain_name $toolchain_version "match_name,verion=" $eb_tc_name_match $eb_tc_ver_match
	# check of toolchain name is found in array eb_tc_name
	if [ "$toolchain_name" == "${eb_tc_name[$i]}" ]; then
		eb_tc_name_match=1
	fi
	# when easyconfig toolchain version use version='' instead of version='dummy' skip version check evaluation 
	if [ ${#eb_tc_ver[$i]} == 0 ]; then
		continue
	fi
	# if toolchain is not a hidden file do a normal string comparison of version found in easyconfig, otherwise strip the leading "." when the version is a hidden file
	if [ ! $hidden_version_file ]; then
		# if toolchain version is found in array eb_tc_ver 
		if [ "$toolchain_version" == "${eb_tc_ver[$i]}" ]; then
			eb_tc_ver_match=1
		fi
	else
		if [ "$strip_toolchain_version_hiddenfile" == "${eb_tc_ver[$i]}" ]; then
			eb_tc_ver_match=1
		fi
	fi
        # dummy toolchain version can be either the value 'dummy' or '' in easyconfig so we ignore match from easyconfig for dummy toolchain
        if [ "$toolchain_version" == "dummy" ]; then
                  eb_tc_ver_match=1
        fi

	#cho "END: name,ver="${eb_tc_name[$i]} ${eb_tc_ver[$i]} "toolchain=" $toolchain_name $toolchain_version "match_name,verion=" $eb_tc_name_match $eb_tc_ver_match

done

if [ $eb_tc_name_match == 0   ] || [ $eb_tc_ver_match == 0 ]; then
	echo "Toolchain name/version mismatch, check files for correct toolchain options: "
	for file in "${easyconfig_file[@]}"
	do
		echo -e "$file \n"
	done
	exit 1
fi

# when there is no test directory for software in the src directory, stop execution 
if [ ! -d $BUILDTEST_SRCSWDIR ]; then
	echo "No test directory found: $BUILDTEST_SRCSWDIR, please create it and add test before running BuildTest"
	exit 1
fi

# if the test directory exist for the software in the src directory, but no test files then halt execution
if [ $(ls $BUILDTEST_SRCSWDIR | wc -l) == 0 ]; then
	echo "No test found in $BUILDTEST_SRCSWDIR, please add test before running BuildTest"
	exit 1
fi
# split string by space and put in array. Since multiple modules can be 
# passed we need to process each module separately
extramodules=(${depmodules// / })
 
# ensure every execution does a clean purge on the destdir before writing test.
if [ -d $destdir ]; then
	rm -rf $destdir
fi
mkdir -pv $destdir

# checking whether to add software to CMakeLists using add_subdirectory. The return code should be 0 when
# a test exists for that software and 1 when its the first test.

if [ ! -f testing/CMakeLists.txt ]; then
	echo "add_subdirectory($software)" > testing/CMakeLists.txt
else 
	grep_ret_code=`grep -w ${software} testing/CMakeLists.txt >/dev/null; echo $?`
	if [ $grep_ret_code == 1 ]; then
		echo "add_subdirectory($software)" >> testing/CMakeLists.txt
	fi
fi

# if no CMakeLists in software directory, create and add the version to CMakeLists
if [ ! -f $destdir/../../../CMakeLists.txt ]; then
	echo "add_subdirectory($version)" > $destdir/../../../CMakeLists.txt
else
	# Each software directory has individual version directory, the statement below
	# ensures cmake to find test inside the version directory
	grep_ret_code=`grep -w ${version} $destdir/../../../CMakeLists.txt >/dev/null; echo $?`
	if [ $grep_ret_code == 1 ]; then
        	echo "add_subdirectory($version)" >> $destdir/../../../CMakeLists.txt
	fi
fi

# check if there is no CMakeLists.txt in version directory, if so do a grep before adding.
if [ ! -f $destdir/../../CMakeLists.txt ]; then
        echo "add_subdirectory($toolchain_name)" > $destdir/../../CMakeLists.txt
else
	grep_ret_code=`grep -w ${toolchain_name} $destdir/../../CMakeLists.txt >/dev/null; echo $?`
	if [ $grep_ret_code == 1 ]; then
        	echo "add_subdirectory($toolchain_name)" >> $destdir/../../CMakeLists.txt
	fi
fi
# if there is no CMakeLists.txt for toolchain name directory then no need to search, just add an entry. Otherwise do a grep before adding
if [ ! -f $destdir/../CMakeLists.txt ]; then
        echo "add_subdirectory($toolchain_version)" > $destdir/../CMakeLists.txt
else
	# check if entry exists in CMakeLists.txt before adding to avoid duplicate entries
	grep_ret_code=`grep -w ${toolchain_version} $destdir/../CMakeLists.txt >/dev/null; echo $?`
	if [ $grep_ret_code == 1 ]; then
        	echo "add_subdirectory($toolchain_version)" >> $destdir/../CMakeLists.txt
	fi
fi

currentcommand="$0 $@"
#processing command.txt for each software package
if [ -f $cmdfile ]; then

	# process each command from command.txt and generate a shell script for each command and update CMakeLists.txt to add test
	while read -r cmd
	do
		executable=`echo $cmd | cut -f 1 -d " " `
		parameter=`echo $cmd | cut -f 1 -d " " `
		cp $BUILDTEST_TEMPLATEDIR/base.sh	$destdir/$executable.sh
		# if -b is specified then toolchain must be loaded. This is the case for packages dependent on GCC, Intel, 
		if [ "$toolchain" != "dummy/dummy" ]; then
        	        sed -i '4i module load '$toolchain $destdir/$executable.sh
	        fi
        
		sed -i 's/module=/module='$software'/g' $destdir/$executable.sh
	        sed -i 's/version=/version='$version'/g' $destdir/$executable.sh

		echo "$cmd " >> $destdir/$executable.sh
		echo "add_test(NAME $software-$version-$toolchain_name-$toolchain_version-$executable     COMMAND sh $executable.sh         WORKING_DIRECTORY \${CMAKE_CURRENT_SOURCE_DIR})" >> $destdir/CMakeLists.txt
	
		echo "Creating Test $destdir/$executable"
	done < $cmdfile
fi
# if there are sourcefiles provided for the test then process them 
#for directory in "$BUILDTEST_SRCSWDIR/*";

for directory in $(ls -1 $BUILDTEST_SRCSWDIR);
do
	# don't process any files, only directories
	if [ ! -d $BUILDTEST_SRCSWDIR/$directory ]; then
		continue
	fi
	
	for file in $(ls -1 $BUILDTEST_SRCSWDIR/$directory);
	do

		if [ $directory == "generic" ]; then
			if [ -f $BUILDTEST_SRCSWDIR/generic/setup.sh ]; then
				source $BUILDTEST_SRCSWDIR/generic/setup.sh
			else
				source $BUILDTEST_SRCDIR/setup.sh
			fi
			templatefile=$BUILDTEST_TEMPLATEDIR/generic.sh
		elif [ $directory == "mpi" ]; then
			if [ -f $BUILDTEST_SRCSWDIR/mpi/setup.sh ]; then
				source $BUILDTEST_SRCSWDIR/mpi/setup.sh
			else
				echo "Missing file $BUILDTEST_SRCSWDIR/mpi/setup.sh, please create it and setup wrappers like CC, FC, CXX"
				exit 1
			fi
			templatefile=$BUILDTEST_TEMPLATEDIR/mpi.sh
		# if there is a custom directory use the template in src/<software>/template.sh
		elif [ $directory == "custom" ]; then
			templatefile=$BUILDTEST_SRCSWDIR/template.sh
		# all other directories are skipped
		else
			continue
		fi
 
		if [ $file == "setup.sh" ]; then
			continue
		fi
		# need to make test unique, in the case of two files with same name from different directories can overwrite test,
		# so adding the directory as part of the filename will fix the issue. For instance generic/hello.c and mpi/hello.c
		# will create a file generic_hello.c.sh and mpi_hello.c.sh 
		testname=$directory-$file.sh
		cp $templatefile $destdir/$testname

		ext=(`echo ${file} | cut -f2 -d.`)
                # C and cuda files extension uses $CC variable 
                if [ $ext == "c" ] || [ $ext == "cu" ]; then
                        sed -i 's/COMPILER=/COMPILER='${CC}'/g' $destdir/$testname
                elif [ $ext == "f" ]; then
                        sed -i 's/COMPILER=/COMPILER='${FC}'/g' $destdir/$testname
                elif [ $ext == "f90" ]; then
                        sed -i 's/COMPILER=/COMPILER='${F90}'/g' $destdir/$testname
                elif [ $ext == "f77" ]; then
                        sed -i 's/COMPILER=/COMPILER='${F77}'/g' $destdir/$testname
                elif [ $ext == "cpp" ]; then
                        sed -i 's/COMPILER=/COMPILER='${CXX}'/g' $destdir/$testname
                fi

                # loading toolchain module in test script if specified 
                if [ "$toolchain" != "dummy/dummy" ]; then
                        sed -i '4i module load '$toolchain $destdir/$testname
                fi

                sed -i 's/module=/module='$software'/g' $destdir/$testname
                sed -i 's/version=/version='$version'/g' $destdir/$testname



                # replace every / with \/ so that sed command can be applied properly on SOURCE tag
                sedcmd=$(echo $BUILDTEST_SRCSWDIR/${directory}/$file | sed  -re 's:/:\\/:g')
                sed -i 's/SOURCE=/SOURCE='$sedcmd'/g' $destdir/$testname

                echo "add_test(NAME $software-$version-$toolchain_name-$toolchain_version-$testname     COMMAND sh $testname         WORKING_DIRECTORY \${CMAKE_CURRENT_SOURCE_DIR})" >> $destdir/CMakeLists.txt

                echo "Creating Test $destdir/$testname"
	done	
done
