Overview
=================

.. contents::
   :backlinks: none

Workflow
---------

Shown below is a high level overview of buildtest architecture for building tests

.. image:: buildtest_workflow.png
   :width: 800
   :height: 400

When you clone buildtest from github, you are also getting the test configuration and source files that is required
to build the test.

In order to build a test, you will be using the ``buildtest build`` command to generate the test scripts. The test scripts
are generated by processing a test configuration (YAML) that goes through a YAML parser for type checking. In this
stage, buildtest will check all keys and values defined in the test configuration. If there is an issue with YAML parser, buildtest
will terminate, otherwise it will proceed to the **builder**.

The builder is responsible for taking the parsed YAML file and generate a test script. First, buildtest will detect the
programming language which can be determined by file extension of the source file. Second, buildtest will detect the compiler or
mpi wrapper based on programming language and details from test configuration.

buildtest will insert ``module load`` during the build phase from one of the four components:

    1. Active Modules
    2. User Collection
    3. buildtest module collection
    4. Module Permutation

During the build phase, buildtest will detect the shell extension and detect any YAML keys for job configuration. If
test configuration contains any job configuration detail, then buildtest will generate a job script, otherwise it will default
to a test script. Currently, buildtest supports LSF and SLURM when generating job script and sh, bash, and csh for test script.

Build Options (``buildtest build --help``)
---------------------------------------------


.. program-output:: cat scripts/buildtest-build-help.txt

Test Configuration
-------------------

buildtest makes use of test configuration to generate the test script. This
can be done by running ``buildtest build -c <test-config>``.

Shown below is an example run::

    $ buildtest build -c compilers.helloworld.hello_gnu.yml
    Writing Test: /tmp/buildtest/suite/compilers/helloworld/hello_gnu.yml.sh


buildtest has two levels of verbosity that can be set by using ``-v`` option.
buildtest will check the programming language, compiler and verify all the
keys in configuration file before building the test.

buildtest will set the permission of test script to ``755``.

::

    $ buildtest build -c compilers.helloworld.hello_gnu.yml -v
    Key Check PASSED for file /home/siddis14/buildtest-framework/toolkit/buildtest/suite/compilers/helloworld/hello_gnu.yml
    Programming Language Detected: c++
    Compiler Check Passed
    Writing Test: /tmp/buildtest/suite/compilers/helloworld/hello_gnu.yml.sh
    Changing permission to 755 for test: /tmp/buildtest/suite/compilers/helloworld/hello_gnu.yml.sh



You may specify additional level verbosity by ``-vv`` or specify ``-v -v``
which will give additional output including the output of configuration file and test
script.

.. program-output:: cat scripts/build-single-configuration.txt

For a complete list of test configuration and names that can be passed to ``buildtest build -c <testconfig>`` run the
following command::

    $ buildtest testconfigs list

See :ref:`Managing_TestConfigs` for details regarding test configuration.


Hello World C++
----------------

Let's take a look at a hello world C++ example that will be compiled with gcc

.. program-output:: cat scripts/configuration/hello_gnu.yml

The first line ``compiler: gnu`` is to indicate we will use the gnu compiler
during compilation.

The ``flags: -O3`` will insert the build flag **-O3** during compilation

The key ``maintainer`` is a list of maintainers that are primary
contact for the test & configuration file

The key ``source: hello.cpp`` is the source file, this file will need to
reside in **src** directory wherever you have your yml file

Finally, ``testblock: singlesource`` inform buildtest that this
is a single source compilation and buildtest will use the appropriate Class to
build this test. Currently, ``testblock`` only supports singlesource at this moment.



Next let's see the generated test script

.. program-output:: cat scripts/tests/hello_gnu.yml.sh

Couple things to note.

- buildtest will purge and load the module that is active in your shell
- The test script will be named with the yml file and the appropriate shell extension ``.sh``, ``.bash``, ``.csh``.
- buildtest will ``cd`` into the test directory where test script is found
- buildtest will detect the compiler based on extension type specified in ``source`` tag. In this case it will be ``g++`` since we specified  ``compiler: gnu``
- buildtest will compile the source file that was defined in ``source`` tag. buildtest will figure out the full path to file.
- The name of the executable will be the name of the source code with ``.exe`` extension.
- Finally buildtest will run executable and remove it upon completion.

OpenMP Example
---------------

Let's take a look at a OpenMP yml example for computing vector dot product

.. program-output:: cat scripts/configuration/omp_dotprod.c.yml

To run a OpenMP example you typically set the environment variable ``OMP_NUM_THREADS``
to declare number of threads during execution.

This can be configured used ``vars:`` keyword that takes a list of of key-value to set
environment variable in the test script. In this example we set ``OMP_NUM_THREADS=2``

To specify flags to linker ``(ld)`` then use key ``ldflags``. In this case, to compile
openmp with gnu compiler you need to specify ``-fopenmp``.

.. _Testing_With_Modules:

Testing with modules
--------------------

Now that we have built a couple test, we want to leverage modules to test
a particular test with different modules. This may be particularly useful if
you have some test that you want to compare with different compilers, MPI,
etc...

Let's take the same hello world example and build it with different gcc
compilers.

Recall the first test was the following

.. program-output:: cat scripts/tests/hello_gnu.yml.sh

In buildtest, just load the modules of interest before you build the test and
it will insert all the modules in  the test script.

For this example we have the following modules loaded

::

    $ ml

    Currently Loaded Modules:
      1) GCCcore/8.3.0               3) zlib/1.2.11-GCCcore-8.3.0   5) libreadline/8.0-GCCcore-8.3.0   7) SQLite/3.29.0-GCCcore-8.3.0   9) GMP/6.1.2-GCCcore-8.3.0     11) Python/3.7.4-GCCcore-8.3.0
      2) bzip2/1.0.8-GCCcore-8.3.0   4) ncurses/6.1-GCCcore-8.3.0   6) Tcl/8.6.9-GCCcore-8.3.0         8) XZ/5.2.4-GCCcore-8.3.0       10) libffi/3.2.1-GCCcore-8.3.0  12) PyCharm/2017.2.3


Let's rebuild the test and notice how the modules are loaded in the test


.. code-block:: console
    :linenos:
    :emphasize-lines: 21-32

    $ buildtest build -c compilers.helloworld.hello_gnu.yml -vv
    ________________________________________________________________________________
    compiler: gnu
    description: Hello C++ example using GNU compiler
    flags: -O3
    maintainer:
    - shahzeb siddiqui shahzebmsiddiqui@gmail.com
    source: hello.cpp
    testblock: singlesource

    ________________________________________________________________________________
    Key Check PASSED for file /u/users/ssi29/gpfs/buildtest-framework/toolkit/suite/compilers/helloworld/hello_gnu.yml
    Source File /u/users/ssi29/gpfs/buildtest-framework/toolkit/suite/compilers/helloworld/src/hello.cpp exists!
    Programming Language Detected: c++
    Compiler Check Passed
    Writing Test: /tmp/ssi29/buildtest/tests/Intel/Haswell/x86_64/rhel/7.6/build_17/hello_gnu.yml.sh
    Changing permission to 755 for test: /tmp/ssi29/buildtest/tests/Intel/Haswell/x86_64/rhel/7.6/build_17/hello_gnu.yml.sh
    ________________________________________________________________________________
    #!/usr/bin/sh
    module purge
    module load GCCcore/8.3.0
    module load bzip2/1.0.8-GCCcore-8.3.0
    module load zlib/1.2.11-GCCcore-8.3.0
    module load ncurses/6.1-GCCcore-8.3.0
    module load libreadline/8.0-GCCcore-8.3.0
    module load Tcl/8.6.9-GCCcore-8.3.0
    module load SQLite/3.29.0-GCCcore-8.3.0
    module load XZ/5.2.4-GCCcore-8.3.0
    module load GMP/6.1.2-GCCcore-8.3.0
    module load libffi/3.2.1-GCCcore-8.3.0
    module load Python/3.7.4-GCCcore-8.3.0
    module load PyCharm/2017.2.3
    cd /tmp/ssi29/buildtest/tests/Intel/Haswell/x86_64/rhel/7.6/build_17
    g++ -O3 -o 0x3301055bf7978d6a40058294d0af4152.exe /u/users/ssi29/gpfs/buildtest-framework/toolkit/suite/compilers/helloworld/src/hello.cpp
    ./0x3301055bf7978d6a40058294d0af4152.exe
     rm ./0x3301055bf7978d6a40058294d0af4152.exe
    ________________________________________________________________________________
    Writing Log file to:  /tmp/ssi29/buildtest/tests/Intel/Haswell/x86_64/rhel/7.6/build_17/log/buildtest_15_26_21_10_2019.log



buildtest will run ``module purge`` and load all the active modules by
running ``module -t list`` and insert each module in a separate line. This
gives user freedom to load whatever module they want when creating test, though
this puts responsibility on user to understand the testscript.





