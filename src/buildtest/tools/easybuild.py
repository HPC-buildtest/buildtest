############################################################################
#
#  Copyright 2017-2019
#
#  https://github.com/HPC-buildtest/buildtest-framework
#
#  This file is part of buildtest.
#
#  buildtest is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  buildtest is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with buildtest.  If not, see <http://www.gnu.org/licenses/>.
#############################################################################

"""
This module checks for easyconfig files in a module tree by searching module
files and the installation directory for .eb files.

This module determines if a software module is a easybuild module by checking
if an easyconfig is found in the installation directory
"""
import os
import sys
import subprocess

from buildtest.tools.config import config_opts
from buildtest.tools.file import string_in_file, walk_tree
from buildtest.tools.modules import get_module_list
from buildtest.tools.utility import get_appname, get_appversion


def find_easyconfigs_from_modulelist(modulelist):
    """This method returns a list of easyconfig from a list of module files."""

    # list to store easyconfigs
    ec_list = []

    # list to store if no easyconfigs found
    no_ec_list = []

    # look for variable root in modulefile
    search_str = "local root ="

    for module in  modulelist:
        # if variable root found in module file then read file and find value
        # assigned to root to get root of software
        if string_in_file(search_str, module):
            content = open(module).readlines()
            for line in content:
                # if line starts with string "local root = <path>" then get PATH
                if line.startswith(search_str):
                    root_path = line.split()[-1]
                    root_path = root_path.replace('"', '')

                    # trying to find directory easybuild inside the root of the
                    # installation directory of an application
                    easybuild_path = os.path.join(root_path, "easybuild")
                    # if directory exist then run the find command
                    eb_file = walk_tree(easybuild_path, ".eb")

                    # only add to list ec_list if there is an easyconfig file
                    if len(eb_file) > 0:
                        ec_list += eb_file

                    break
                else:
                    continue
        else:
            no_ec_list.append(f"Reading File: {module} "
                              + "Unable to find variable root in module file. "
                              + "This module is not generated by easybuild")


    return ec_list,no_ec_list

def find_easyconfigs():
    """ This method prints the easyconfig lists in a table format and it
        implements buildtest list --easyconfigs. """


    modulelist = get_module_list()

    ec_list,no_ec_list = find_easyconfigs_from_modulelist(modulelist)

    # if one or more easyconfigs found then display the path to easyconfigs
    if len(ec_list) > 0:
        print ("List of easyconfigs found in MODULETREES: %s"
               % (config_opts['BUILDTEST_MODULE_ROOT']))
        print
        print ("ID   |  easyconfig path")
        print("{:_<4} | {:_<80}".format ("", ""))
        count = 1
        for ec in ec_list:
            print ("{:4} | {:15}".format(count, ec))
            count = count + 1
    else:
        print ("No easyconfigs found!")

    if len(no_ec_list) > 0:
        print("\n")
        print ("Unable to find easyconfigs for the following, please "
               + "investigate this issue! \n")

        for no_ec in  no_ec_list:
            print (no_ec)

    print (f"Total easyconfigs found:{len(ec_list)}")
    print (f"Total module files searched: {len(modulelist)}")


def is_easybuild_app():
    """ This method returns True if an easyconfig file found in
        installation directory. """
    app_name = get_appname()
    app_ver = get_appversion()

    modulefiles = []
    modtrees = config_opts["BUILDTEST_MODULE_ROOT"]
    for tree in modtrees:
        for root, dirs, files in os.walk(tree):
            for file in files:
                # skipping files that are symbolic links
                if os.path.islink(os.path.join(root,file)):
                    continue

                # only add module file to list specified by -s <app>/<version>.
                if  (os.path.splitext(file)[0] == app_ver \
                    and os.path.basename(root) == app_name):
                    modulefiles.append(os.path.join(root,file))

    ec_list, no_ec_list = find_easyconfigs_from_modulelist(modulefiles)
    # if no easyconfigs found then ec_list will be empty so we should stop and report this application is not built by easybuild. This feature can be changed in future
    if len(ec_list) == 0:
        print ("Application: " + os.path.join(app_name,app_ver) + " is not built from Easybuild, cannot find easyconfig file in installation directory")
        sys.exit(1)

    return
